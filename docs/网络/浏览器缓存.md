# 浏览器缓存
- 浏览器对最近请求数据缓存到本地，再次访问的时候可以直接调用本地数据提高响应速度和减轻服务器压力
- 分为强缓存（`Fresh Cache`）和协商缓存（`Conditional Cache`）
- 合理的设置缓存能减轻服务器压力，提高页面响应速度
- 不是所有请求都会有这两种缓存机制，没有这两种机制的时候通常是浏览器自己决定
- 这些缓存机制通常由后端控制
- 通常这两种缓存策略不会出现在同一个请求中，如果同时出现则先判断强缓存

## 强缓存
- 发起请求的时候浏览器根据`Cache-Control`或`Expires`确定缓存是否过期，过期则会直接在本地读取缓存
- 命中强缓存时**不会发起请求**响应`200`（磁盘读取`from disk cache`），控制台会有这个请求记录
- 未命中则进入协商缓存
### 场景
适用于静态资源，图像、`css`文件、`js`文件等变动不频繁的资源，使用场景和 `Last-Modified` 重叠
### 实现
通过 `HTTP` 响应头标识来控制缓存时间和策略
1. `Cache-Control`: `HTTP/1.1` ，资源过期的**相对时间**，目前普遍使用
   - 参数
     - `max-age`: 设置资源的最大有效期（相对时间），如 `Cache-Control: max-age=3600`，表示资源在 `3600` 秒（1小时）内有效
     - `public`: 表示资源可以被任何缓存（浏览器或CDN）缓存
     - `private`: 表示资源只能被私有缓存（仅浏览器）缓存，通常用于用户敏感数据
     - `no-cache`: 并不是禁止缓存，而是要求每次在使用缓存前，必须先向服务器验证资源的有效性，配合协商缓存使用
     - `no-store`: 完全禁止缓存，每次请求都从服务器获取

2. `Expires`: `HTTP/1.0`，资源过期的**绝对时间**，依赖客户端本地时间有可能出错
   - 示例: `Expires: Wed, 21 Oct 2023 07:28:00 GMT`

:::tip 这两种方式可能会在一个请求同时出现，优先使用`Cache-Control`
`Cache-Control` 是较新的规范，且提供了更灵活的控制
:::

:::tip `max-age` 配置的时间浏览器怎么确认过期的
浏览器在首次请求缓存数据的时候会记录时间戳，后续请求可以使用这个时间戳来和 `max-age` 对比计算
:::


## 协商缓存
- 一定会发起请求和服务器创建链接，由服务器决定返回数据还是客户端使用缓存
- 返回`304`则使用客户端缓存，`200` 则返回新数据

### 场景
`ETag`: 适用于需要经常变动的内容，`api`返回的数据 动态的`html`
`Last-Modified`: 适用于静态资源，图像、`css`文件、`js`文件等变动不频繁的资源，可以有效减少无用的数据响应

### 实现
通过 `HTTP` 响应头标识来控制缓存时间和策略
1. `ETag` 和 `If-None-Match`（浏览器会优先使用，对服务器有一定开销）
   - 精确度高，可感知文件内容改动来决定是否使用缓存，适合动态资源
   - `ETag`: 服务器在响应头中返回的一个标识符，表示资源的内容唯一性，通常是资源内容的哈希值
     - 示例: `ETag: "5d8c72a5edda7"`
   - `If-None-Match`: 在后续请求中，浏览器在请求头带上 `If-None-Match` 值为上次的 `ETag` 值
   - 整体流程
     1. 首次请求服务器在请求响应头携带 `ETag` 
     2. 后续请求浏览器在请求头携带 `If-None-Match`
     3. 服务器再次生成 `ETag` 和客户端的 `If-None-Match` 对比
     4. 返回 `304` 表示使用缓存，`200` 服务器则返回新数据
   - 优点: 根据文件哈希值判断内容精确度高，支持并发修改检测，对于经常变动的资源也能很好的支持，对于大文件的改动即使改动小也能察觉
   - 缺点: 服务计算哈希值有性能开销，哈希碰撞

2. `Last-Modified` 和 `If-Modified-Since`
   - `Last-Modified`: 服务器在初次响应中提供资源的最后修改时间，文件修改时间
     - 示例: `Last-Modified`: `Wed, 21 Oct 2023 07:28:00 GMT`
   - `If-Modified-Since`: 在后续请求中，浏览器会在请求中添加 `If-Modified-Since` 值为上次响应的 `Last-Modified` 的值
   - 整体流程
     1. 首次请求服务器在响应头携带 `Last-Modified`
     2. 后续请求浏览器在请求头携带 `If-Modified-Since`
     3. 服务器根据 `If-Modified-Since` 和文件修改时间对比
     4. 返回 `304` 表示使用缓存，`200` 服务器则返回新数据
   - 优点: 简单易用 性能好 服务器和浏览器广泛支持
   - 缺点: 文件修改时间不够精确，动态生成的资源无法准确反映内容变化

:::tip 这两种方式一般不会同时出现，如果同时出现的话浏览器会优先使用 `ETag`
:::

:::tip 对于 `json` 数据的 `api` 请求
大多数都是不设置缓存，`ETag` 可以根据 `json` 内容生成哈希值，`Last-Modified` 可以使用数据库改动时间
:::

:::tip 希望每次请求都是向服务器请求最新的数据，不使用缓存
可以设置 `Cache-Control: no-store`，表示禁止所有缓存，不会命中强缓存也不走协商缓存
:::

:::tip 缓存清理机制
浏览器会根据缓存大小，当前可用空间来清理一些不常用的缓存数据
:::
