# 文件上传

## 普通上传
- 直接将文件对象通过 `FromData` 的方式上传到后端即可

:::tip
  `FromData` 的 `append` 会将数字自动转字符串
:::

## 分片上传
- 主要注意文件的切片，上传队列并发控制


### 文件切片

1. 创建一个上传文件的类 `FileUploader` 并初始化一些必要变量

```js

class FileUploader {
  constructor(file, options = {}) {
    this.file = file
    const { chunkSize = 5, api, onProgress = () => {}, maxConcurrency = 5 } = options
    this.chunkSize = chunkSize * 1024 * 1024

    // 上传状态 ready: 准备上传 uploading: 上传中 pausing: 暂停中 paused: 暂停 failed: 上传失败 completed: 全部上传完成
    this.status = 'ready'

    // 上传接口
    this.uploadApi = api

    // 总分片数
    this.totalChunks = 0
    // 已上传的分片数
    this.uploadedChunks = 0
    // 失败的任务分片数据
    this.failedTasks = []

    // 进度回调
    this.onProgress = onProgress

    // 最大并发数
    this.maxConcurrency = maxConcurrency

    // 上传队列
    this.queue = []
    // 当前正在上传的任务数
    this.activeTasks = 0
  }

  /** 上传状态 */
  _setStatus(status) {
    this.status = status
  }
}

```
2. 文件切片方法
```js
/** 创建切片 */
_createChunks() {
  const file = this.file
  const chunkSize = this.chunkSize
  // 切片集合
  const chunks = []
  // 切片数量
  this.totalChunks = Math.ceil(file.size / chunkSize)
  for (let i = 0;i < this.totalChunks;i++) {
    const start = i * chunkSize;
    const end = Math.min(start + chunkSize, file.size);
    chunks.push({
      index: i,
      chunk: file.slice(start, end, file.type),
    });
  }
  return chunks
}
```
:::tip
  考虑在 `worker` 中执行切片操作，避免浏览器 `ui` 卡顿
:::

3. 单个分片上传
```js
/** 上传分片 */
async _uploadChunk(chunk) {
  if (!this.uploadApi) throw new Error("上传接口未定义");
  const formData = new FormData();
  formData.append("chunkFile", chunk.chunk);
  formData.append("index", chunk.index);
  formData.append("total", this.totalChunks);
  formData.append("fileName", this.file.name);
  await this.uploadApi(formData);
}
```
4. 任务线程执行函数
   1. 这里创建的是一个自动往里添加任务的线程队列
   2. 最大并发是4的话就执行4次
   3. 这里的4条线程都会在一个任务完成后自动添加下一个任务
   4. 后续无任务后这里的 `promise` 才会结束
```js
/** 处理上传队列 */
async _processQueue() {
  while (this.queue.length > 0) {
    if (this.status !== 'uploading') break; // 如果暂停或状态变更，停止处理
    const task = this.queue.shift(); // 从队列中取出一个任务（上传分片函数）
    this.activeTasks++; // 增加活跃任务数
    try {
      await task(); // 执行上传任务
      this.uploadedChunks++;
      this.onProgress(this.uploadedChunks / this.totalChunks);
    } catch (err) {
      // 上传失败，将分片重新放入失败列表
      this.failedTasks.push(task);
    } finally {
      this.activeTasks--; // 任务完成，减少活跃任务数
    }
  }
}
```
5. 上传函数
```js
/** 开始上传 */
async upload() {
  const chunks = this._createChunks()
  this._setStatus('uploading')
  // 初始化任务队列
  this.queue = chunks.map((chunk) => () => this._uploadChunk(chunk));
  const uploadPromises = [];
  // 创建最大并发数量的任务
  for (let i = 0;i < this.maxConcurrency;i++) {
    uploadPromises.push(this._processQueue());
  }
  // 等待所有上传线程完成
  await Promise.all(uploadPromises);
  
  // 重试一次失败的分片任务
  if (this.failedTasks.length) {
    try {
      await this.retry()
    } catch (err) {
      throw new Error('失败了一部分切片')
    }
    return
  }
  if (!this.queue.length) this._setStatus('completed')
}
```
6. 重传函数
   1. 收集上传失败的分片任务进行统一重试
```js
/** 失败的分片进行重传 */
async retry() {
  if (!this.failedTasks.length) return console.warn('没有失败的任务');
  if (!navigator.onLine) return console.error('当前网络不可用，请检查网络连接后重试');
  this.queue = [...this.failedTasks]; // 将失败的上传任务重新加入队列
  this.failedTasks = [];
  this._setStatus('uploading');
  const retryPromises = [];
  for (let i = 0;i < this.maxConcurrency;i++) {
    retryPromises.push(this._processQueue());
  }
  await Promise.all(retryPromises);
  if (this.failedTasks.length > 0) {
    this._setStatus('failed');
    console.error(`仍有 ${this.failedTasks.length} 个分片未上传成功`);
  } else {
    this._setStatus('completed');
  }
}
```
7. 暂停和恢复
   1. 这里暂停的效果是停止每个线程继续添加任务
   2. 正在上传的切片无法取消仍会继续上传
```js
/** 暂停上传 */
pause() {
  if (this.status !== 'uploading') return;
  this._setStatus('paused');
}
/** 恢复上传 */
async resume() {
  if (this.status !== 'paused') return;
  this._setStatus('uploading');
  const resumePromises = [];
  for (let i = 0;i < this.maxConcurrency;i++) {
    resumePromises.push(this._processQueue());
  }
  await Promise.all(resumePromises);
  if (this.failedTasks.length > 0) {
    this._setStatus('failed');
    console.error(`仍有 ${this.failedTasks.length} 个分片未上传成功`);
  } else {
    this._setStatus('completed');
  }
}
```
